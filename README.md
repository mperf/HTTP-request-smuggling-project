# HTTP-request-smuggling-project

#### Report

#### Problem Statement
Modern web applications often rely on multiple servers, such as a front-end proxy and a back-end application server, to handle HTTP traffic efficiently. However, these servers do not always interpret HTTP requests in exactly the same way. Small differences in how they handle headers like Content-Length and Transfer-Encoding can cause them to disagree on where one request ends and the next begins.
This inconsistency can be exploited by an attacker to smuggle hidden HTTP requests through the connection, a vulnerability known as HTTP Request Smuggling. Because the front-end and back-end see different versions of the same request, the attacker’s hidden payload can bypass security checks, manipulate server behavior, or access data belonging to other users.

#### References 
We used the PortSwigger Lab as a starting point for our own lab. We studied their exercises to gain a practical understanding of HTTP request smuggling and to analyse example request/response patterns. However, we implemented all infrastructure, scenarios and tasks for this project independently. For learning purposes only, we reproduced key behaviours observed in the PortSwigger material, then designed and developed original lab tasks and solutions.

#### Documentation of project
The project was developed in a four phase process. The first phase began with the topic and a method. We had decided to create a lab that demonstrates how HTTP-request smuggling works. A solid theoretical foundation was needed for the creation of the lab. The first phase was therefore focused on gathering theory. In the second phase of the project, the structure of the lab was decided. We created a rough plan for the layout, created a github repository and put together theory in a structured document. We also came up with the plan for the infrastructure of the lab. The focus of the third phase of the project was setting up the lab environment. An interface was partially created, but later scrapped for a different infrastructure. We also decided on adding theory questions to the lab. This enabled us to add a lot of necessary background theory, without simply presenting the student solving the lab with a wall of reading material. Finally, the fourth phase focused on finishing touches. Solutions to the theoretical and practical questions were finished.

Our lab addresses how HTTP requests normally work, how they can be exploited through request smuggling and how these exploits can be prevented. The main focus however, is on how request smuggling works. The lab is structured in a way that aims to guide a student with no prior knowledge, through the process of creating an HTTP-request smuggling attack. The lab starts off with a tutorial that explains how HTTP works. The student then moves on to the three tasks. Task 1 covers the basics of how HTTP request smuggling uses headers. Task 2 is an introduction to how HTTP request smuggling can be used maliciously. Task 3 presents different types of HTTP request smuggling and one attack to leak passwords.
Improvements to the lab could come in the form of prevention tasks. We discussed including tasks that teaches the student how http request smuggling is prevented, but chose to focus on the tasks that teaches the student how to perform the attack.

#### Documentation on testing the project
All parts of the Lab can be run via each task folder's respective “test.py”. Running them requires the servers to be set up and running in the docked, which is documented in the “README.md” inside the “lab” folder. This makes it easier to run the lab, whilst also making it more secure and guaranteeing that the servers will work. Notably, docker (tested for version 28.5.1) and python3 (tested for version 3.11.2) are necessary to run this lab.

Running a “test.py” will test the solutions the user has written, reading them from designated files. Assuming everything is set up correctly; the requests and responses will be printed in the terminal, allowing more insight into what the server sees and what might have gone wrong in the case of a failed test. Similar to how other labs in this course work, successful test cases will be shown as “OK”.


#### Contributions
##### Mattia Perfumo
Developed the Docker virtual infrastructure for the lab, including two web servers, a sample script to simulate the attack, and the task objectives. The development started by analyzing the HTTP Request Smuggling vulnerability and how it can be exploited. The lab was designed to provide a hands-on experience to understand the vulnerability and explore different attack vectors. My approach was to create a first server that handles authentication via HTTP Basic Authentication and a second server exposing different endpoints, some of which are protected by the first server. I encountered challenges in finding the right configuration for the servers to simulate the vulnerability effectively. I tried different services and configurations, including using Nginx, Apache, and documented CVEs, but eventually settled on a different approach that allowed for a more straightforward setup. The final architecture relies on a script that sends the student's requests to the first server and, after some milliseconds, it sends inside the same connection (crucial for the attack) a victim request. This enabled different attack vectors, which were then documented as objectives for the lab. The first objective is to redirect the victim to another page, potentially allowing the attacker to perform actions on behalf of the victim. The second objective is to delete the victim's account, demonstrating the impact of the vulnerability. Moreover, the last objective is to leak the victim's headers, which contain the authentication information. These objectives were then translated into tasks for the students to complete by my colleagues, who provided detailed instructions and explanations for each task.

##### Sarah Winter
My main contribution to the group project was researching and writing the theory section on HTTP and HTTP Request Smuggling. I spent a considerable amount of time reading and experimenting with examples in order to gain a thorough understanding of how HTTP works, how requests and responses are constructed, the function of headers, and how different servers handle them. I also investigated how reverse proxies and back-end servers interact, as this information is crucial for identifying potential smuggling vulnerabilities. Next, I delved deeper into the topic of request smuggling itself: how this kind of attack works in practice; why it happens; the vulnerabilities it exploits; and how it can be prevented. Armed with this knowledge, I wrote the theory section of our report and created the theory questions and lab tasks. The aim was to create exercises that would help students to understand the topic step by step rather than just memorise it. This took a considerable amount of time as it was surprisingly difficult to write questions that were both clear and challenging. I had to rewrite and adjust several of the questions so that they matched the rest of the lab setup and guided students towards understanding the concept independently. In addition, I wrote the solutions for all the theory tasks. While the others focused mainly on building and testing the lab environment, I worked on the research, writing and task design, which required a great deal of independent work and problem solving. Overall, I spent a considerable amount of time learning, experimenting and writing to ensure that the theoretical aspect of the project was comprehensive and comprehensible.

##### Lukas Malmberg
My focus during this project has been on research, lab structure and writing the report. After we had decided on creating a lab as our project, I created an initial lab structure. This detailed how we organised the background theory, instructions questions, etc. I then moved on to researching the theory behind how HTTP request smuggling works. Since I had no prior knowledge, this was by far the most time consuming, but also the most educational part of the project for me. I started my research by simply reading as much material as possible. From this, I gained an understanding of how HTTP is supposed to work and why the vulnerability exists. I did not however actually understand how an attack would be performed in practice. What made me gain a proper understanding of request smuggling was PortSwigger’s page on request smuggling, especially the visualisations were very helpful. From the information and knowledge gathered, I wrote a theory section that Sarah combined with her theory work and later transformed into theory questions. Towards the end of the project I’ve focused on writing the documentation of the report and doing some minor touchups. Overall throughout the project, my role has been that of a support character, helping out where needed. We began the project by dividing up responsibilities, where I was supposed to create the lab structure and set up a website. The website was however scratched and I moved my focus to research/theory along with Sarah. Even though the lab is presented in a way that portrays other potential students as the ones learning about the subject, I personally have learned a lot more about HTTP request smuggling through the project, than I would have done if I was presented with a similar lab. 


##### Fabian Andréasson
At the beginning of the project my main contributions were in designing the attacks, or more specifically; how we could design the attacks in an easy to use, yet also intuitive way for exploring this vulnerability in a learning environment. I did, like others in the group, a lot of research on HTTP- although I was more focused on how to compile HTTP manually and how communicating with servers would look from the users end. Whilst I started experimenting with ncat and postman- and how we could automate it with bash-scripts, we didn’t end up using those apps. In the end Mattia set up a server which could interact quite nicely with Python3, so instead of continuing on using ncat I refactored what I had made into .py scripts; inspired by how existing labs and exercises already do it in this course. As I did this I also spent a lot of time using the theory Sarah and Lucas had written and fine-tuned it into the tasks that could easily be checked automatically. Simultaneously, I did testing on setting up the environment (seeing that it actually worked on more than just one group member's machine) and wrote down instructions (and a tiny bit of troubleshooting) for how to run the lab. Given more time, I would have worked towards finding a smoother way of setting up the docker; maybe more similar to Lab W? Currently it needs to run a docker-compose, which probably could be automated more like zoobar.

### Acknowledgment
This task was designed by:         <br>
Mattia Perfumo                     <br>
Fabian Andréasson                  <br>
Lukas Malmberg                     <br>
Sarah Winter                       <br>


### useful links

https://nathandavison.com/blog/haproxy-http-request-smuggling
